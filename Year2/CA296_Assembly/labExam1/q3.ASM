; very nice effort indeed.
; again, as with other questions, I would look at this to try and see if 
; you can perhaps shorten the code and make it more efficient.
; basic idea is good, and I like the way you deal with strings of different lengths.
ORG C0
DB 48			; C0 HAS "HeJlO" with null at end as marker of end of string
DB 65			; D0 HAS "HeLlO" with marker too....
DB 4C
DB 6C

DB 0
ORG D0
DB 48
DB 65
DB 4C
DB 6C
DB 4A
DB 0

ORG 0
MOV CL,C0		; FIRST STRING COMPARISON
MOV DL,D0		; SECOND STRING	COMPARISON
MOV AL,[CL]		; GET LETTER THAT CL POINTS TO INTO AL
MOV BL,[DL]		; GET LETTER THAT DL POINTS TO INTO BL
LOOP:
	CMP AL,BL	; ARE THEY THE SAME
	JNZ NO_MATCH	; IF THEY DON'T MATCH, WE END
	INC CL		; ELSE INCREMENT CL AND DL TO GET NEXT LETTER
	INC DL
	MOV AL,[CL]	; MOVE THE LETTERS INTO AL AND BL
	MOV BL,[DL]
	CMP AL,0	; HAVE WE REACHED END OF FIRST STRING
	JZ IS_BL	; WE NEED TO CHECK WE REACHED END OF SECOND STRING TOO
	CMP BL,0	; ELSE IF WE HAVEN'T REACHED END OF FIRST STRING, WHAT IF WE REACHED END OF BL
	JZ NO_MATCH	; IF SO, STRINGS HAVE DIFFERENT LENGTHS SO WE JUMP TO NO_MATCH
	JMP LOOP	; ELSE, CONTINUE

IS_BL:
	CMP BL,0	; SINCE AL IS AT END, IS BL?
	JZ MATCH	; IF SO, WE REACHED END AND THEY MATCH
	JMP NO_MATCH	; ELSE KEEP THEY DON'T MATCH

NO_MATCH:
	MOV AL,01	; SET AL AS 01 IF THERE'S NO MATCH
	JMP ENDING

MATCH:
	MOV AL,00	; SET AL AS 00 IF THERE'S A MATCH
	JMP ENDING

ENDING:
	END